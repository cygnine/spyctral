# !/usr/bin/env python
# 
# Routines for finding orthogonal polynomial quadrature

__all__ = ['opoly_gq', 'opoly_grq', 'opoly_glq']

from numpy import array, sqrt, diag, dot
from numpy.linalg import eigh, inv
from opoly1 import eval_opoly
import numpy as np
#from scipy import sparse

def gq(a,b) :
# Returns the N-point Gaussian quadrature associated by the orthogonal
# polynomials generated by the recurrence constants a and b (numpy arrays). N is
# the length of the recurrence constant vectors.
    from numpy import array, max, diag
    from numpy.linalg import eigh

    a = array(a);
    b = array(b);

    assert (a.ndim==1)&(b.ndim==1), "Recurrence inputs a and b must be 1-D arrays"
    N = a.size

    Ntmp = max(a.size,b.size)
    if N>Ntmp : 
        print "Downgrading N from %d to %d" % (N,Ntmp)
        N = Ntmp;
        a = a[:N]; b = b[:N]

    # Define Jacobi matrix
    J = diag(a[:N]) + diag(sqrt(b[1:N]),1) + diag(sqrt(b[1:N]),-1)
    # Eigenvalues/vectors
    [x,d] = eigh(J)
    w = b[0]*(d[0,:]**2)

    return [x,w]

def grq(a,b,r0=-1.) :
# Returns the N-point Gauss-Radau quadrature associated with the orthogonal
# polynomials defined by the recurrence constants a and b (numpy arrays). The
# input r0 denotes the fixed Radau point. N is the length of the recurrence
# constant vectors.
   
    from eval import eval_opoly

    a = array(a);
    b = array(b);

    assert (a.ndim==1)&(b.ndim==1), "Recurrence inputs a and b must be 1-D arrays"
    N = a.size

    Ntmp = max(a.size,b.size)
    if N>Ntmp : 
        print "Downgrading N from %d to %d" % (N,Ntmp)
        N = Ntmp;
        a = a[:N]; b = b[:N]

    # Same as doing Gauss quadrature with a modified recurrence relation
    temp = eval_opoly(r0,[N-2, N-1],a,b).squeeze()
    a[N-1] = r0 - b[N-1]*temp[0]/temp[1]

    return gq(a=a,b=b)

# Returns the N-point Gauss-Lobatto quadrature associated with the orthogonal
# polynomials defined by the recurrence constants a and b. The input r0 denotes
# the fixed Lobatto points.
def glq(a,b,r0=[-1.,1.]) :
    from numpy import array, dot
    from numpy.linalg import inv
    from eval import eval_opoly

    # Still have to do argument checking:
    a = array(a);
    b = array(b);

    assert (a.ndim==1)&(b.ndim==1), "Recurrence inputs a and b must be 1-D arrays"
    N = a.size

    Ntmp = max(a.size,b.size)
    if N>Ntmp : 
        print "Downgrading N from %d to %d" % (N,Ntmp)
        N = Ntmp;
        a = a[:N]; b = b[:N]

    # Same as doing Gauss quadrature with a modified recurrence relation
    temp = eval_opoly(r0,[N-1, N-2],a,b).squeeze()
    rhs = array([r0[0]*temp[0,0], r0[1]*temp[1,0]]).reshape([2,1])
    modif = dot(inv(temp),rhs).squeeze()
    a[N-1] = modif[0]
    b[N-1] = modif[1]

    return gq(a=a,b=b)
