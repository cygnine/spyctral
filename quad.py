# !/usr/bin/env python
# 
# Routines for finding orthogonal polynomial quadrature

__all__ = ['opoly_gq', 'opoly_grq', 'opoly_glq']

from numpy import array, sqrt, diag, dot
from numpy.linalg import eigh, inv
from opoly1 import eval_opoly
import numpy as np
#from scipy import sparse

# Returns the N-point Gaussian quadrature associated by the orthogonal
# polynomials generated by the recurrence constants a and b. 
def opoly_gq(a,b,N) :

    a = array(a);
    b = array(b);

    assert (a.ndim==1)&(b.ndim==1), "Recurrence inputs a and b must be 1-D arrays"

    Ntmp = max(a.size,b.size)
    if N>Ntmp : 
        print "Downgrading N from %d to %d" % (N,Ntmp)
        N = Ntmp;

    # Define Jacobi matrix
    J = diag(a[:N]) + diag(sqrt(b[1:N]),1) + diag(sqrt(b[1:N]),-1)
    # Fortran can't do sparse stuff built-in:
#    J = sparse.lil_matrix([N,N])
#    J.setdiag(a[:N])
#    J.setdiag(sqrt(b[1:N]),1)
#    J.setdiag(sqrt(b[1:N]),-1)

    [x,d] = eigh(J)

    w = b[0]*(d[0,:]**2)

    return [x,w]

# Returns the N-point Gauss-Radau quadrature associated with the orthogonal
# polynomials defined by the recurrence constants a and b. The input r0 denotes
# the fixed Radau point. 
def opoly_grq(a,b,N,r0=-1.) :

    # Still have to do argument checking:
    a = array(a);
    b = array(b);

    assert (a.ndim==1)&(b.ndim==1), "Recurrence inputs a and b must be 1-D arrays"

    Ntmp = max(a.size,b.size)
    if N>Ntmp : 
        print "Downgrading N from %d to %d" % (N,Ntmp)
        N = Ntmp;

    # Same as doing Gauss quadrature with a modified recurrence relation
    #temp = eval_opoly(r0,[N-2, N-1],a,b).squeeze()
    temp = eval_opoly(r0,[N-2, N-1],a,b).squeeze()
    a[N-1] = r0 - b[N-1]*temp[0]/temp[1]

    return opoly_gq(N=N,a=a,b=b)

# Returns the N-point Gauss-Lobatto quadrature associated with the orthogonal
# polynomials defined by the recurrence constants a and b. The input r0 denotes
# the fixed Lobatto points.
def opoly_glq(a,b,N,r0=[-1.,1.]) :

    # Still have to do argument checking:
    a = array(a);
    b = array(b);

    assert (a.ndim==1)&(b.ndim==1), "Recurrence inputs a and b must be 1-D arrays"

    Ntmp = max(a.size,b.size)
    if N>Ntmp : 
        print "Downgrading N from %d to %d" % (N,Ntmp)
        N = Ntmp;

    # Same as doing Gauss quadrature with a modified recurrence relation
    temp = eval_opoly(r0,[N-1, N-2],a,b).squeeze()
    rhs = array([r0[0]*temp[0,0], r0[1]*temp[1,0]]).reshape([2,1])
    modif = dot(inv(temp),rhs).squeeze()
    a[N-1] = modif[0]
    b[N-1] = modif[1]

    return opoly_gq(N=N,a=a,b=b)
